<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Sushi: The DAW Inside Elk &#8212; Elk DevKit  documentation</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/blank.css?v=c4c5097c" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=4a788ece" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script src="../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sushi Internal Plugins" href="sushi_internal_plugins.html" />
    <link rel="prev" title="Examples Overview" href="elk_examples_overview.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../index.html">
<p class="title">Elk DevKit</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../intro/index.html">
  Introduction
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="index.html">
  Sushi
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../embedded/index.html">
  Embedded OS reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../legacy/index.html">
  Legacy documentation
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/elk-audio" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="elk_examples_overview.html">
   Examples Overview
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Sushi: The DAW Inside Elk
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sushi_internal_plugins.html">
   Sushi Internal Plugins
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sushi_configuration_format.html">
   Sushi Configuration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sushi_public_api_model.html">
   Sushi Public API Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sushi_control_grpc.html">
   Controlling Sushi using gRPC
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sushi_control_osc.html">
   Controlling Sushi using Open Sound Control
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../elkpy-doc/modules.html">
   gRPC helper libraries
  </a>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#main-features">
   Main Features
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#architecture">
   Architecture
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#audio-frontends">
   Audio Frontends
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#configuration-and-control">
   Configuration and Control
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sushi-s-public-api-model">
   Sushi’s Public API Model
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#json-configuration-file">
     JSON Configuration File
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#run-time-control">
     Run-Time Control
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#end-user-control">
     End-User Control
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#examples-on-configuration-and-control">
     Examples on Configuration and Control
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discovering-initial-sushi-configuration-s-available-parameters">
   Discovering Initial Sushi Configuration’s Available Parameters
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#plugin-format-support">
   Plugin Format Support
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#threading">
   Threading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#twine">
   Twine
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#logging">
   Logging
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#configuring-sentry">
   Configuring Sentry
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#running-sushi-with-a-different-buffer-size">
   Running Sushi with a Different Buffer Size
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="sushi-the-daw-inside-elk">
<h1>Sushi: The DAW Inside Elk<a class="headerlink" href="#sushi-the-daw-inside-elk" title="Link to this heading">¶</a></h1>
<p>The Elk Music Operating System consists of many different parts. Here we focus on what we call <strong>Sushi</strong>,
the DAW that is at the core of audio and midi processing in the Elk MusicOS.</p>
<section id="main-features">
<h2>Main Features<a class="headerlink" href="#main-features" title="Link to this heading">¶</a></h2>
<p>Sushi is a track-based, headless Digital Audio Workstation. It works as
a plugin host, supporting multiple plugin standards. It features advanced
audio and midi routing, simple scripting setup, and is written to ensure
high performance and stability under low latency conditions. It can be
controlled through MIDI, OSC, and a gRPC interface.</p>
<p><strong>In a nutshell:</strong></p>
<ul class="simple">
<li><p>Headless host with full run-time control over MIDI, gRPC and OSC interfaces.</p></li>
<li><p>Hosts VST 2.4, VST 3.7 and LV2  plugins.</p></li>
<li><p>Highly optimized for low latency performance.</p></li>
<li><p>Multithreaded audio processing support.</p></li>
<li><p>Ableton Link support.</p></li>
<li><p>Audio connections through Raspa, Jack, Portaudio, Core Audio and file I/O.</p></li>
<li><p>Simple scripting configuration.</p></li>
</ul>
</section>
<section id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Link to this heading">¶</a></h2>
<p>Sushi shares the same basic architecture with most common DAWs like
Cubase or Ableton Live, having an unlimited number of parallel channels.
Most closely it is comparable to Logic Mainstage, in that it is a Live DAW.
Each track supports mono, stereo or up to 64 audio channels and as
many plugins as the CPU can handle. Pure MIDI tracks are also supported,
for instance outputting MIDI from an arpeggiator or step sequencer to an
external device.</p>
<p>There is also a multibus track mode with which a multichannel track can
have multiple stereo outputs, <strong>each with their own individual gain and
panning controls</strong>, which in turn can be routed to any audio output.
Useful for multi bus plugins. Sushi also features aux sends and
corresponding return tracks for effects processing.</p>
<p>In addition, Sushi allows adding pre and post tracks, each with as many
channels as there are audio inputs and outputs in sushi. They can be used
for pre-processing audio inputs before routing to individual tracks and
for adding master effects to the audio outputs.</p>
</section>
<section id="audio-frontends">
<h2>Audio Frontends<a class="headerlink" href="#audio-frontends" title="Link to this heading">¶</a></h2>
<p>Sushi supports multiple audio frontends:</p>
<ul class="simple">
<li><p><strong>RASPA</strong>: Sushi was built to work in perfect sync with Raspa, our
proprietary low-latency audio framework.</p></li>
<li><p><a class="reference external" href="http://jackaudio.org/">JACK Audio Toolkit</a>: for running
real-time code on normal Linux machines.</p></li>
<li><dl class="simple">
<dt><strong>PortAudio</strong>: For running realtime on macOS using Core Audio, Asio or</dt><dd><p>Directsound on Windows, or Linux using JACK or ALSA.</p>
</dd>
</dl>
</li>
<li><p><strong>Core Audio</strong> Native audio on macOS.</p></li>
<li><p><strong>Offline</strong>: for processing audio and scripted event files (e.g. for
automatic testing).</p></li>
<li><p><strong>Dummy</strong>: without any connection to audio I/O, useful to debug some
real-time safety issues on normal Linux machines.</p></li>
</ul>
<p><strong>The ability to run Sushi with Jack, the most common audio framework on
Linux, makes it possible to run on almost any Linux system</strong>. While it
doesn’t give the same ultra low latency as running it with Raspa on an
Elk system. It does make it incredibly easy to test and develop plugins
and setups for Elk on a standard Linux machine. In fact, <strong>almost all of
the development of Sushi has been done on standard Linux machines</strong>.</p>
<p>When running with RASPA, PortAudio or Core Audio, Sushi is limited to the number
of inputs and outputs supported by the physical hardware. While when
running with Jack, Sushi exposes 8 input ports and 8 output ports that
can then be freely routed to physical outputs or inputs, or other Jack software.</p>
<p>The Offline frontend can be used for testing in environments that
lack audio codecs and for evaluating systems in a very early stage. It
has also proven to be very useful in debugging.</p>
<p>See Sushi’s integrated usage help (by running <em>sushi -h</em> or
<em>sushi –help</em>), for command line options to choose one of the
frontends.</p>
</section>
<section id="configuration-and-control">
<h2>Configuration and Control<a class="headerlink" href="#configuration-and-control" title="Link to this heading">¶</a></h2>
<p>Sushi supports a number of protocols and technologies for controlling
and syncing with external sources and devices: MIDI, gRPC, Open Sound Control (OSC), Ableton Link.</p>
<p>As Sushi is a headless host, and intended for use in an embedded device,
it does not feature a graphical user interface. Instead, we have implemented several means of control,
which can be used together or separately to set Sushi up, and control it during run-time.</p>
<ul class="simple">
<li><p>The initial setup is done through a <a class="reference external" href="https://en.wikipedia.org/wiki/JSON">JSON</a> configuration file.</p></li>
<li><p>At run-time, Sushi can be controlled via two API’s available over the network: gRPC, and OSC.</p></li>
<li><p>End-users can additionally control Sushi and hosted plugins directly, using MIDI and Ableton Link, with the added flexibility of OSC for more advanced users.</p></li>
</ul>
<figure class="align-default">
<img alt="img" src="../_images/sushi_architecture.png" />
</figure>
</section>
<section id="sushi-s-public-api-model">
<h2>Sushi’s Public API Model<a class="headerlink" href="#sushi-s-public-api-model" title="Link to this heading">¶</a></h2>
<p>While Sushi is accessible and configurable over several means, i.e. a json configuration file, gRPC and OSC,
the model they all control is the same.</p>
<p>It is thus best to describe this common model once below, and then address individual peculiarities for the
separate control avenues available.</p>
<p>Please refer to the dedicated section on the <a class="reference internal" href="sushi_public_api_model.html#sushi-public-api-model"><span class="std std-ref">Sushi Public API Model</span></a> for the full description.</p>
<section id="json-configuration-file">
<h3>JSON Configuration File<a class="headerlink" href="#json-configuration-file" title="Link to this heading">¶</a></h3>
<p>In the JSON configuration file it is possible to specify the initial number of tracks to use, their channel setup, the plugins on the track, audio
input and output routing, MIDI routing, which plugin parameters map to
Control Change messages, and so on. See below for a very simple example
for how to set up a synth plugin with MIDI-mapped parameters.</p>
<p>Sushi’s JSON format is fully specified in a JSON schema, but it is
probably easier to learn by studying the provided examples, which cover
most common configurations, including multitrack/multichannel
configurations.</p>
<p>See our documentation on the <a class="reference external" href="sushi_configuration_format.html">Sushi Configuration
Format</a> for more details.</p>
</section>
<section id="run-time-control">
<h3>Run-Time Control<a class="headerlink" href="#run-time-control" title="Link to this heading">¶</a></h3>
<p>The majority of run-time functionality is available using Google’s gRPC,
which offers full control of all aspects of Sushi and hosted plugins,
with bidirectional communication to a remote client.</p>
<p>With the run-time gRPC API it is possible to perform the majority of tasks desired.
gRPC has bindings for most common programming languages. This gives total freedom to customise the behaviour and write
a complete GUI for Sushi in more or less any GUI framework of choice and account for multiple use cases.
Please see the dedicated subheading <a class="reference internal" href="sushi_control_grpc.html#sushi-control-grpc"><span class="std std-ref">Controlling Sushi using gRPC</span></a>,
for comprehensive information on Sushi’s gRPC features.</p>
<p>An additional API based on <a class="reference external" href="http://opensoundcontrol.org/">Open Sound Control</a> (OSC) is available,
which covers a smaller subset of control for Sushi, than gRPC.
Sushi can both send OSC updates and receive notes and parameter changes through OSC.
Please see the dedicated subheading <a class="reference internal" href="sushi_control_osc.html#sushi-control-osc"><span class="std std-ref">Controlling Sushi using Open Sound Control</span></a> for more details on Sushi’s OSC features.</p>
</section>
<section id="end-user-control">
<h3>End-User Control<a class="headerlink" href="#end-user-control" title="Link to this heading">¶</a></h3>
<p>MIDI input and output is supported through
<a class="reference external" href="https://www.alsa-project.org/">ALSA</a>, or RtMidi (for accessing CoreMIDI on macOS). This enables integration with
any class compliant midi device, like USB MIDI keyboards or controllers.
<strong>A flexible routing system allows you to route MIDI based on channels
to any track</strong>. MIDI can be freely routed to tracks and MIDI Program
Change and Control Change messages can be mapped to plugins and
parameters respectively. MIDI data can also be processed or generated by
plugins like sequencers. Sushi can output midi clock messages but not sync to incoming midi clock.</p>
<p>Sushi also features <strong>tempo sync over Ableton Link</strong>, which enables
you to seamlessly tempo sync Sushi with other devices over wifi. This
works with computers running <a class="reference external" href="https://www.ableton.com/">Ableton Live</a>
or any Link enabled mobile app like <a class="reference external" href="https://itunes.apple.com/se/app/reason-compact-make-music/id1253419004">Reason
Compact</a>
or <a class="reference external" href="https://www.korg.com/uk/products/software/korg_gadget/">Korg
Gadget</a>.</p>
</section>
<section id="examples-on-configuration-and-control">
<h3>Examples on Configuration and Control<a class="headerlink" href="#examples-on-configuration-and-control" title="Link to this heading">¶</a></h3>
<p>Used in combination, the above enable the creation of rich devices.</p>
<p>For some applications, user interactions will come from both front panel
knobs and a handheld device, i.e. a smartphone or tablet.
In that case, an app running on the handheld can use the gRPC interface to control Sushi.
Initial configurations are over</p>
<p>Other Elk devices could feature a built-in screen. In that case
the GUI will run on the same CPU as Sushi, though in a different
process. But as mentioned before, the GUI can be built in Python or any
other programming language of choice. <strong>The dual kernel architecture of
Elk will guarantee that the graphics rendering will never interfere with
the audio dsp processing.</strong></p>
<p>Meanwhile, end-users can integrate your device with their other media devices,
using MIDI, Ableton Link, and OSC.</p>
</section>
</section>
<section id="discovering-initial-sushi-configuration-s-available-parameters">
<h2>Discovering Initial Sushi Configuration’s Available Parameters<a class="headerlink" href="#discovering-initial-sushi-configuration-s-available-parameters" title="Link to this heading">¶</a></h2>
<p>These can be discovered in several ways.</p>
<p>The name, label, ID and OSC paths for the hosted plugins’ parameters, is
dumped to stdout in JSON format when running Sushi with the flag
<em>–dump-plugins</em>. For example, to pipe the parameters for the LV2 JX10
example configuration into a .json file, type the following:</p>
<p><em>$ sushi –dump-plugins -c /config_play_lv2_jx10.json &gt; jx10_parameters.json</em></p>
<p>This flag starts sushi with the dummy frontend and exits immediately
after dumping the parameters.</p>
<p>Parameter values are normalized to the range 0.0-1.0, floating point,
across plugin formats.</p>
<p>So, from the above example, to set the JX 10 synthesizers’ resonance to 0.5
(halfway its range), send the following OSC message to Sushi (the
default UDP port for this is 24024):</p>
<p><em>/parameter/jx10/VCF_Reso, f, 0.5</em></p>
<p>The parameters can also be queried over gRPC’s ParameterController,
documented under <a class="reference internal" href="sushi_control_grpc.html#sushi-control-grpc"><span class="std std-ref">Controlling Sushi using gRPC</span></a>.</p>
</section>
<section id="plugin-format-support">
<h2>Plugin Format Support<a class="headerlink" href="#plugin-format-support" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Sushi can host plugins in Steinberg’s <strong>VST 2.4</strong> and <a class="reference external" href="https://www.steinberg.net/en/company/technologies/vst3.html">VST
3.7</a>
formats, <strong>LV2</strong> (natively as well as using the LV2VST wrapper), plus
an Internal plugin format, which all are abstracted in a generic
“Processor” interface.</p></li>
</ul>
<p>In order to load plugins in Sushi, they need to be compiled for the
system intended. Note that it is not possible to take an existing
Windows, macOS, or even native Linux plugin binary and load it in Elk.
That will not work. Though if the plugins are well written from the
start, porting them to Elk should be a rather straightforward process of
recompiling the plugins using our SDK.</p>
<p>Paths to plugin binaries can either be absolute or relative to the path set by the <em>–base-plugin-path</em> commmand line argument.</p>
</section>
<section id="threading">
<h2>Threading<a class="headerlink" href="#threading" title="Link to this heading">¶</a></h2>
<p>Sushi can run its audio processing single threaded but also has <strong>built
in multithreading support</strong> to spread the audio processing over multiple
cores, depending on the type of system it is running on. To enable multicore audio processing, start sushi with the <em>-m/–multicore</em> option.</p>
<p>When creating tracks it’s possible to set the audio processing thread for that track using the <em>thread</em> argument. If the <em>thread</em> argument is not set, tracks will be allocated to threads according to a round-robin scheme.</p>
<p>Note that thread is an abstract concept and does not directly map to physical CPU cores. If sushi is started with the <a href="#id1"><span class="problematic" id="id2">*</span></a>-m2” option, the audio processing with be split over 2 thread and the possible values for the thread argument is hence 0 and 1.</p>
<p>For Elk Audio OS systems it’s possible to directly control which CPU cores sushi use for audio processing. See the Elk Audio OS documentation.</p>
<p>For developers that wish to utilize multithreading within a plugin, we have developed a small threading utility library that works with Elk and Sushi, called Twine.</p>
</section>
<section id="twine">
<h2>Twine<a class="headerlink" href="#twine" title="Link to this heading">¶</a></h2>
<p>Twine is a C++ library that exposes some features of the underlying
Xenomai system to plugin developers, particularly accurate and real-time
safe timers, and multithreaded worker pools.</p>
<p>The library has a fall-back implementation for POSIX systems (tested on
standard Linux distros and macOS), which makes it convenient for
inclusion in an existing codebase. Twine also has limited functionality on Windows</p>
<p>Full source code is included in <em>work/twine</em> with Doxygen
documentation, unit tests and example code.</p>
</section>
<section id="logging">
<h2>Logging<a class="headerlink" href="#logging" title="Link to this heading">¶</a></h2>
<p>On start, Sushi creates a log file in <em>/tmp/sushi.log</em> where it logs
all relevant run-time information. Logging level and log destination can
be specified with the command line flag <em>-l</em> or <em>–log-level</em> and
<em>-l</em> or <em>-L</em> <em>-log-file=filename</em> respectively.</p>
</section>
<section id="configuring-sentry">
<h2>Configuring Sentry<a class="headerlink" href="#configuring-sentry" title="Link to this heading">¶</a></h2>
<p>Sushi can be built with sentry for crash handling by setting the <cite>SUSHI_WITH_SENTRY</cite>
CMake variable to ON.</p>
<p>The default DSN to which sentry will upload the minidumps and crash
reports, can be set with the <cite>SUSHI_SENTRY_DSN</cite> CMake variable, or overriden at
runtime with the <cite>–sentry-dsn=&lt;dsn.address&gt;</cite> flag when starting sushi.</p>
<p>To catch crashes sushi needs to know the location of the <cite>crashpad_handler</cite>
binary that is compiled along with sentry-native. The default location is
<cite>./crashpad_handler</cite> but this can be overriden with the
<cite>–sentry-crash-handler=&lt;path/to/crashpad_handler&gt;</cite> flag when starting sushi.</p>
<p>For sentry to symbolicate the crash logs, symbol files must be <a class="reference external" href="https://docs.sentry.io/platforms/native/data-management/debug-files/upload/">uploaded to sentry</a>.</p>
<p>More info on symbol files can be found <a class="reference external" href="https://docs.sentry.io/platforms/native/data-management/debug-files/file-formats/">here</a>.</p>
</section>
<section id="running-sushi-with-a-different-buffer-size">
<h2>Running Sushi with a Different Buffer Size<a class="headerlink" href="#running-sushi-with-a-different-buffer-size" title="Link to this heading">¶</a></h2>
<p>Audio buffer-size is a compile-time option in Sushi, since on embedded
systems there’s rarely the need from the user to adjust the buffer size
and in this way, the compiler has more room for optimizations.</p>
<p>However, Elk distributions are shipped with Sushi compiled at different
buffer sizes, usually [16, 32, 64, 128].</p>
<p>In case you want to use a different buffer size, you will also need to
change the audio driver parameter <em>audio_buffer_size</em> in the script
placed by default in <em>/usr/bin/load-drivers</em> and reboot the board (or
restart the audio driver by removing and reinserting the module
<em>audio_rtdm</em>).</p>
</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="elk_examples_overview.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Examples Overview</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="sushi_internal_plugins.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Sushi Internal Plugins</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2023, Elk.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>